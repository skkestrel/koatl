import functools.wraps

export Reader = class:
    __init__ = (self, fn) => self.fn = fn

    __repr__ = self => "Reader(...)"

    run = (self, ctx) => self.fn(ctx)

    bind_once = (self, f) => Reader& ctx =>
        v = f(self.fn(ctx))
        if v matches Reader():
            v.fn(ctx)
        else:
            v

    # TODO: this is a workaround to avoid recursion.
    # how to get bind_gen directly from bind_once?
    bind_gen = (self, gen) => Reader& ctx =>
        nonlocal self = self
        try:
            while True:
                self = gen.send(self.fn(ctx))
        except StopIteration(value=value):
            return value

    NoKey = object()

    ask = staticmethod& (key=NoKey) => Reader(
        key === Reader.NoKey then ctx => ctx else ctx => ctx[key]
    )

    pure = staticmethod& value => Reader(ctx => value)